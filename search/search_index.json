{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Page title One more, finally. Or not? :) Now: $ some Look what she said: This is it! Section1 And now this: One Two Three As well As this Another a link More? Can we now have the build ? NOW! Not gonna work, is it?","title":"Home"},{"location":"#page-title","text":"One more, finally. Or not? :) Now: $ some Look what she said: This is it!","title":"Page title"},{"location":"#section1","text":"And now this: One Two Three","title":"Section1"},{"location":"#as-well","text":"","title":"As well"},{"location":"#as-this","text":"","title":"As this"},{"location":"#another","text":"a link More? Can we now have the build ? NOW! Not gonna work, is it?","title":"Another"},{"location":"I.%20Overview/1.%20What%20is%20Cerberus-Sandbox%20%3F/","text":"","title":"1. What is Cerberus Sandbox ?"},{"location":"I.%20Overview/2.%20How%20it%20works%20%3F/","text":"","title":"2. How it works ?"},{"location":"II.%20Development%20Procedures/1.%20Updating%20the%20docs/","text":"Updating the docs This online documentation is generated using mkdocs and is hosted on a Github Pages . The following procedure explains how to build this documentation on your own system, and how to upgrade the live one. Local Setup In order to build the local version of this documentation, the mkdocs package is required: $ pip install mkdocs $ mkdocs -V mkdocs, version 1.1.2 from /usr/lib/python3.8/site-packages/mkdocs (Python 3.8) To get the last version of the documentation's file, clone the Cerberus Sandbox public GitHub repository in one of your local folder: $ git clone https://github.com/Cerberus-Sandbox/cerberus-sandbox.github.io The GitHub repository is composed of two branches: main and master . The first one holds the raw mkdocs files, and the second one is the compiled version of the website used by GitHub to host the live instance. You should never edit the master branch by hand. Even in a local setup. Now that you hold a local copy of the documentation website, simply run mkdocs build to generate the compiled HTML pages. The entrypoint of the local setup is located in site/index.html . If you want to edit the live content, or if you need to add a new page, everything will be done in the docs/ folder. A typical architecture can be resumed by the following: docs/ \u251c\u2500\u2500 I. Subsection n\u00b01 \u2502 \u251c\u2500\u2500 1. Doc 1.md \u2502 \u251c\u2500\u2500 2. Doc 2.md \u2502 \u2514\u2500\u2500 3. Doc 3.md \u2514\u2500\u2500 II. Subsection n\u00b02 Each folder holds a subsection of the documentation, and each markedown file stores the actual content of the page. You can refer to the following cheatsheet to edit your markedown file: www.markdownguide.org/cheat-sheet/ Upgrading the live version Whenever the local content is ready to go, you can use the automatic script ship-to-prod.sh to push the new content on GitHub and rebuild the mkdocs instance, or choose to do it by hands. The script is located at the root folder of the cerberus-sandbox repository. You can choose to pass a short description of your modification to the script, as a string value, for a better understanding of each commit: $ chmod +x ./ship-to-prod.sh $ ./ship-to-prod.sh \"index update + typo\" And that's it, shortly after that, the upgraded version of the documentation website should be up and running. For the manual process, two steps are needed: First, the mkdocs sources need to be saved in the main branch: $ git pull $ git checkout main $ git add docs/* $ git add mkdocs.yml $ git commit -m \"your commit message\" $ git push If you don't push to the main branch, the next modifications will erase yours, and nobody will be able to track and download your modifications. Then, the mkdocs sources can be compiled and shiped to the github master branch: $ mkdocs gh-deploy --force --remote-branch master And that's it. Remember that you'll have to wait several minutes to see your updates on the live page ! Pages layout Every entry in the Documentation need to follow the same layout. The goal is to keep everything consistent with a set of basics rules for the contributors. This section is basically a list of rules to follow in order to fully integrate your page in this project. A page need to have one (and only one) title, and that title should match the name of the file, even if it contain some special characters or some spaces. ## This is a title It match the file 'This is a title.md' When possible, split your page with sub-sections. It will help the navigation in the side menu, and a quick way to find information in a large page. ### This is a sub-section At the beginning of the page, a short description should be made. This can be a sum-up of the page, or a way to identify what the reader will learn. When the name of a script, a program file, or a path is used, put it in back-quotes: `python` is the best interpreted language Do not write code outside the markedown code blocks: ```python print(\"this is code\") ``` Be as precise as possible when writting about practical technical stuff, and as theoretical as possible when writting about some high-level concepts. Generaly speaking, thoses two part should be keept in separated pages in different sections. But be carrefull not to be too precise. This is a documentation about the Cerberus-Sandbox , we don't need to re-write technical documentation about already-existing tools. Even in a technical installation process, don't blindly list commands to copy and paste. Explain everything that is relevant. Always use relative path, except if the path that you are talking about is standard for everyone. Do not use any hardcoded IP or username in your pages. Do not write down any personnal credentials or API keys.","title":"1. Updating the docs"},{"location":"II.%20Development%20Procedures/1.%20Updating%20the%20docs/#updating-the-docs","text":"This online documentation is generated using mkdocs and is hosted on a Github Pages . The following procedure explains how to build this documentation on your own system, and how to upgrade the live one.","title":"Updating the docs"},{"location":"II.%20Development%20Procedures/1.%20Updating%20the%20docs/#local-setup","text":"In order to build the local version of this documentation, the mkdocs package is required: $ pip install mkdocs $ mkdocs -V mkdocs, version 1.1.2 from /usr/lib/python3.8/site-packages/mkdocs (Python 3.8) To get the last version of the documentation's file, clone the Cerberus Sandbox public GitHub repository in one of your local folder: $ git clone https://github.com/Cerberus-Sandbox/cerberus-sandbox.github.io The GitHub repository is composed of two branches: main and master . The first one holds the raw mkdocs files, and the second one is the compiled version of the website used by GitHub to host the live instance. You should never edit the master branch by hand. Even in a local setup. Now that you hold a local copy of the documentation website, simply run mkdocs build to generate the compiled HTML pages. The entrypoint of the local setup is located in site/index.html . If you want to edit the live content, or if you need to add a new page, everything will be done in the docs/ folder. A typical architecture can be resumed by the following: docs/ \u251c\u2500\u2500 I. Subsection n\u00b01 \u2502 \u251c\u2500\u2500 1. Doc 1.md \u2502 \u251c\u2500\u2500 2. Doc 2.md \u2502 \u2514\u2500\u2500 3. Doc 3.md \u2514\u2500\u2500 II. Subsection n\u00b02 Each folder holds a subsection of the documentation, and each markedown file stores the actual content of the page. You can refer to the following cheatsheet to edit your markedown file: www.markdownguide.org/cheat-sheet/","title":"Local Setup"},{"location":"II.%20Development%20Procedures/1.%20Updating%20the%20docs/#upgrading-the-live-version","text":"Whenever the local content is ready to go, you can use the automatic script ship-to-prod.sh to push the new content on GitHub and rebuild the mkdocs instance, or choose to do it by hands. The script is located at the root folder of the cerberus-sandbox repository. You can choose to pass a short description of your modification to the script, as a string value, for a better understanding of each commit: $ chmod +x ./ship-to-prod.sh $ ./ship-to-prod.sh \"index update + typo\" And that's it, shortly after that, the upgraded version of the documentation website should be up and running. For the manual process, two steps are needed: First, the mkdocs sources need to be saved in the main branch: $ git pull $ git checkout main $ git add docs/* $ git add mkdocs.yml $ git commit -m \"your commit message\" $ git push If you don't push to the main branch, the next modifications will erase yours, and nobody will be able to track and download your modifications. Then, the mkdocs sources can be compiled and shiped to the github master branch: $ mkdocs gh-deploy --force --remote-branch master And that's it. Remember that you'll have to wait several minutes to see your updates on the live page !","title":"Upgrading the live version"},{"location":"II.%20Development%20Procedures/1.%20Updating%20the%20docs/#pages-layout","text":"Every entry in the Documentation need to follow the same layout. The goal is to keep everything consistent with a set of basics rules for the contributors. This section is basically a list of rules to follow in order to fully integrate your page in this project. A page need to have one (and only one) title, and that title should match the name of the file, even if it contain some special characters or some spaces. ## This is a title It match the file 'This is a title.md' When possible, split your page with sub-sections. It will help the navigation in the side menu, and a quick way to find information in a large page. ### This is a sub-section At the beginning of the page, a short description should be made. This can be a sum-up of the page, or a way to identify what the reader will learn. When the name of a script, a program file, or a path is used, put it in back-quotes: `python` is the best interpreted language Do not write code outside the markedown code blocks: ```python print(\"this is code\") ``` Be as precise as possible when writting about practical technical stuff, and as theoretical as possible when writting about some high-level concepts. Generaly speaking, thoses two part should be keept in separated pages in different sections. But be carrefull not to be too precise. This is a documentation about the Cerberus-Sandbox , we don't need to re-write technical documentation about already-existing tools. Even in a technical installation process, don't blindly list commands to copy and paste. Explain everything that is relevant. Always use relative path, except if the path that you are talking about is standard for everyone. Do not use any hardcoded IP or username in your pages. Do not write down any personnal credentials or API keys.","title":"Pages layout"},{"location":"II.%20Development%20Procedures/2.%20Coding%20Standards/","text":"Coding Standards This page is a list of standards that every scripts or programs in the cerberus-sandbox project must match. If a program file does not follow thoses standards, upgrade them. The goal is to bind every file of the project in a global scope, with the same high-level sythax. Navigating through the source code of the sandbox should be as user-friendly as possible, and the code and it's comments must speak for themselves. It will help to integrate new functionality latter, keep everything clear, and eventually to maintain the codebase. Whenever a new script file is added to the project, it name must be the concatenation of what it is doing, keeping only the keywords. Instead of adding spaces, the first letter of each word will be in the uppercase format. i.e: StaticEngine.py , Disassembler.py , PeParser.py or FileDriver.py . Python3 should be the only autorized version of Python. The first line of the script must indicate the encoding. By default, we'll use the UTF-8 encoding. # coding: utf-8 After the encoding, the next 3 lines should be used as a header to indicate the date of creation of the original file, the name of the author and a quick description of what the script is doing, or how to use it. # 17/10/2020 # HomardBoy # Low-level linear disassembler based on the Capstone library. Everything related to the python code should match the PEP-8 standards. To quickly check if a file is following the PEP-8 rules, you can use the pep8 tool: $ pip install pep8 $ pep8 --first Disassembler.py Disassembler.py:222:34: W602 deprecated form of raising exception Disassembler.py:347:31: E211 whitespace before '(' Apart from the PEP-8 standard, you are encouraged to follow those additional rules: For performance, try to only import the Python's modules that you need, not the full library ( never import the full library as from lib import * ): from lib import function For performance reason, string formating should not be done using concatenation of variables and strings, nor by using format strings. Instead, use f-strings. They are faster to load, and very clear to read: name = \"cerberus\" f\"The best sandbox is {name}-sandbox.\" Logs messages should use the Python logger objects. Don't print anything, log it. If your script or function support this usecase, try to pass the log level as an argument. Always keep your logs message as clear and minimal as possible. import logging logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG) logging.debug('I am here for information only') logging.info('I am used to track how the program is going') logging.warning('Something might be broken') logging.error('Something is broken') logging.critical('Everything is broken') Use f-strings inside your loggers objects: logging.error('the file {filename} was not found') Configure the logs of your application to be redirect to a static logfile, and to stdout (you can skip the stdout redirect part if you don't need to; You are in fact advise not to print anything on stdout): logging.basicConfig(filename='out.log', format='[%(asctime)s][%(name)s][%(levelname)s] %(message)s', filemode='w+') logger = logging.getLogger('Application name') # Name of the application that is going to generate logs logger.setLevel('DEBUG') # The static log file should have the higher log level console = logging.StreamHandler() # 'console' identify the logs that should be print to stdout console.setLevel(logging.getLevelName(args.log)) # The console logging is choosen by the user (without affecting the static log file level) formatter = logging.Formatter('[%(asctime)s][%(name)s][%(levelname)s] %(message)s') console.setFormatter(formatter) # Set the format of the stdout logs logger.addHandler(console) # The static file will also get a copy of everything that is print to the console The logger output should be redirect by default to /var/log/cerberus.log : parser.add_argument(\"-o\", \"--output\", help = \"Log file. Default=/var/log/cerberus.log\", required = False, default = \"/var/log/cerberus.log\") logging.basicConfig(filename=args.output, ...) The logs format should match this one (but you can add additionnal fields inside if you need to be more precise): format='[%(asctime)s][%(name)s][%(levelname)s] %(message)s' Functions name should describe the global job of the function, with the same construct as the filename (using uppercase letter for each new word, and without any spaces). The first letter should be lowercase: def addWinApiArguments(): return Variables names must be as clear as possible, without uppercase, using underscore as a \"space\" character: user_input = input(\"How are you ?\") Global variables should be avoided as much as possible. Comment your functions using the Sphinx standard. def disassemble(entry_point, end_point, f): '''Returns the assembly code for a bunch of given bytes :param entry_point: start address of the function to disassemble. Only use for RVA. :type entry_point: integer :param end_point: address of the last instruction of the function. Only used to check if the result is still inside the CODE section. :type end_point: integer :param f: byte representation of the function to disassemble. :type f: bytes-array :returns: Disassembly version of the target function. :rtype: list of strings ''' Try to use multi-thread as much as you can when your script is doing two differents things at the same time. Each part of the sandbox should be design to be as less time-consuming as possible since the sandbox cannot affort to make the end user hang for too long. Performance is key. Use OOP when needed, but don't use it for anything when it doesn't make sense. If what you are writting is going to be used in multiple instances with different values (exception given for functions with kilometers longs list of arguments), then go for OOP. If not, build simple functions or more linear code. Use Python3 build-in functions when you can. It will improve the execution time of your scripts.","title":"2. Coding Standards"},{"location":"II.%20Development%20Procedures/2.%20Coding%20Standards/#coding-standards","text":"This page is a list of standards that every scripts or programs in the cerberus-sandbox project must match. If a program file does not follow thoses standards, upgrade them. The goal is to bind every file of the project in a global scope, with the same high-level sythax. Navigating through the source code of the sandbox should be as user-friendly as possible, and the code and it's comments must speak for themselves. It will help to integrate new functionality latter, keep everything clear, and eventually to maintain the codebase. Whenever a new script file is added to the project, it name must be the concatenation of what it is doing, keeping only the keywords. Instead of adding spaces, the first letter of each word will be in the uppercase format. i.e: StaticEngine.py , Disassembler.py , PeParser.py or FileDriver.py . Python3 should be the only autorized version of Python. The first line of the script must indicate the encoding. By default, we'll use the UTF-8 encoding. # coding: utf-8 After the encoding, the next 3 lines should be used as a header to indicate the date of creation of the original file, the name of the author and a quick description of what the script is doing, or how to use it. # 17/10/2020 # HomardBoy # Low-level linear disassembler based on the Capstone library. Everything related to the python code should match the PEP-8 standards. To quickly check if a file is following the PEP-8 rules, you can use the pep8 tool: $ pip install pep8 $ pep8 --first Disassembler.py Disassembler.py:222:34: W602 deprecated form of raising exception Disassembler.py:347:31: E211 whitespace before '(' Apart from the PEP-8 standard, you are encouraged to follow those additional rules: For performance, try to only import the Python's modules that you need, not the full library ( never import the full library as from lib import * ): from lib import function For performance reason, string formating should not be done using concatenation of variables and strings, nor by using format strings. Instead, use f-strings. They are faster to load, and very clear to read: name = \"cerberus\" f\"The best sandbox is {name}-sandbox.\" Logs messages should use the Python logger objects. Don't print anything, log it. If your script or function support this usecase, try to pass the log level as an argument. Always keep your logs message as clear and minimal as possible. import logging logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG) logging.debug('I am here for information only') logging.info('I am used to track how the program is going') logging.warning('Something might be broken') logging.error('Something is broken') logging.critical('Everything is broken') Use f-strings inside your loggers objects: logging.error('the file {filename} was not found') Configure the logs of your application to be redirect to a static logfile, and to stdout (you can skip the stdout redirect part if you don't need to; You are in fact advise not to print anything on stdout): logging.basicConfig(filename='out.log', format='[%(asctime)s][%(name)s][%(levelname)s] %(message)s', filemode='w+') logger = logging.getLogger('Application name') # Name of the application that is going to generate logs logger.setLevel('DEBUG') # The static log file should have the higher log level console = logging.StreamHandler() # 'console' identify the logs that should be print to stdout console.setLevel(logging.getLevelName(args.log)) # The console logging is choosen by the user (without affecting the static log file level) formatter = logging.Formatter('[%(asctime)s][%(name)s][%(levelname)s] %(message)s') console.setFormatter(formatter) # Set the format of the stdout logs logger.addHandler(console) # The static file will also get a copy of everything that is print to the console The logger output should be redirect by default to /var/log/cerberus.log : parser.add_argument(\"-o\", \"--output\", help = \"Log file. Default=/var/log/cerberus.log\", required = False, default = \"/var/log/cerberus.log\") logging.basicConfig(filename=args.output, ...) The logs format should match this one (but you can add additionnal fields inside if you need to be more precise): format='[%(asctime)s][%(name)s][%(levelname)s] %(message)s' Functions name should describe the global job of the function, with the same construct as the filename (using uppercase letter for each new word, and without any spaces). The first letter should be lowercase: def addWinApiArguments(): return Variables names must be as clear as possible, without uppercase, using underscore as a \"space\" character: user_input = input(\"How are you ?\") Global variables should be avoided as much as possible. Comment your functions using the Sphinx standard. def disassemble(entry_point, end_point, f): '''Returns the assembly code for a bunch of given bytes :param entry_point: start address of the function to disassemble. Only use for RVA. :type entry_point: integer :param end_point: address of the last instruction of the function. Only used to check if the result is still inside the CODE section. :type end_point: integer :param f: byte representation of the function to disassemble. :type f: bytes-array :returns: Disassembly version of the target function. :rtype: list of strings ''' Try to use multi-thread as much as you can when your script is doing two differents things at the same time. Each part of the sandbox should be design to be as less time-consuming as possible since the sandbox cannot affort to make the end user hang for too long. Performance is key. Use OOP when needed, but don't use it for anything when it doesn't make sense. If what you are writting is going to be used in multiple instances with different values (exception given for functions with kilometers longs list of arguments), then go for OOP. If not, build simple functions or more linear code. Use Python3 build-in functions when you can. It will improve the execution time of your scripts.","title":"Coding Standards"},{"location":"II.%20Development%20Procedures/3.%20Git%20Workflow/","text":"","title":"3. Git Workflow"},{"location":"III.%20Installation/","text":"","title":"Index"},{"location":"IV.%20Internal%20Design/","text":"","title":"Index"}]}